use DDP;
use JSON::XS;
use Modern::Perl;

my $api = {name=>'base',text=>'',level=>0,children=>[]};

my $l = $api;
$l->{parent} = $l;

while (<>) {
  my $text = $_;
  my ($level, $name) = $text =~ /^(#+) (.*)/;
  if ($level) {
      $level = length($1);
      my $newLevel = {name=>$name,text=>$text,level=>$level,children=>[]};

      my ($class) = $name =~ /a name="([^"]+)"/;
      if ($class) {
        $class =~ s/-(\w)/\U$1/g;
        $newLevel->{class} = $class;
      }
      my ($meth) = $name =~ /\.([a-zA-Z.]+)/;
      $newLevel->{meth} = $meth if $meth;

      $newLevel->{parent} = $l if ($level > $l->{level});
      $newLevel->{parent} = $l->{parent} if ($level == $l->{level});
      $newLevel->{parent} = $l->{parent}{parent} if ($level < $l->{level});
      if ($meth && $l->{class} && $meth eq $l->{class}) {
          $l->{text} .= $text;
      } else {
          push @{$newLevel->{parent}{children}}, $newLevel;
          $l = $newLevel;
      }
  } else {
      $l->{text} .= $text;
  }
}

sub removeParent {
  my ($n) = @_;

  delete $n->{parent};
  foreach my $c (@{$n->{children}}) {
      removeParent($c);
  }
}

removeParent($api);

print encode_json($api);
#p $api;
#

sub rebuild {
  my ($n) = @_;
  say '#' x $n->{level}, ' ', $n->{name};
  say $n->{class} if $n->{class};
  print $n->{text};
  foreach my $c (@{$n->{children}}) {
    rebuild($c);
  }
}

#rebuild($api);


