
var esprima   = require('esprima'),
    escodegen = require('escodegen');

function getComments(source) {

    var syntax = esprima.parse(source, { raw: true, tokens: true, range: true, comment: true });
        syntax = escodegen.attachComments(syntax, syntax.comments, syntax.tokens);

    var comments = [];

    function parseComments(node,parentComment,within) {
      var comment;
      if(node.leadingComments)
        comment = node.leadingComments[0].value;

      if (parentComment && node.type == 'AssignmentExpression') {
        var left = escodegen.generate(node.left);
        comments.push({value:parentComment, for:left, in: within});
        parseComments(node.right,comment,left);
      }
      else {
        for (var i in node) {
          if (typeof(node[i]) == 'object' && node[i]) {
            parseComments(node[i],comment || parentComment,within);
          }
        }
      }
    }

    parseComments(syntax);
    //console.log(comments);

    console.log(
      comments.map(function(c) {
        var s = +(c.value[0] == '*'),
            e = +(c.value[c.value.length - 1] == '*'),
            value = c.value.slice(s, c.value.length - e).replace(/\s+$/, ''),
            r = /(\n[ \t]+)[^ \t\n]/g,
            prefix,
            result;

        while(result = r.exec(value)) {
            if(prefix === undefined || result[1].length < prefix.length)
                prefix = result[1];
        }

        var norm = value.split(prefix).join('\n').replace(/^\n+/, '');
        if(c.for.match(/^dc\./))
            norm = '## ' + c.for + '\n' + norm;
        else
            norm = '#### ' + c.for + ' in ' + c.in + '\n' + norm;

        return norm;
    }).join('\n\n')
    );
}

var source = '';

process.stdin.resume();

process.stdin.on('data', function(d) {
    source += d.toString();
});

process.stdin.on('end', function() {
    getComments(source);
   // console.log(getComments(source));
});
